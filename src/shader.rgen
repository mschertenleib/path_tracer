#version 460

#extension GL_EXT_ray_tracing: require
#extension GL_EXT_scalar_block_layout: require

#include "shader_common.glsl"

layout (binding = 0, rgba32f) uniform image2D storage_image;

layout (binding = 1) uniform accelerationStructureEXT tlas;

layout (binding = 2, scalar) buffer Vertices
{
    vec3 vertices[];
};

layout (binding = 3, scalar) buffer Indices
{
    uint indices[];
};

layout (push_constant) uniform Push_constants
{
    uint frame_count;
    uint samples_per_frame;
};

layout (location = 0) rayPayloadEXT Ray_payload payload;

void main()
{
    const uvec2 image_size = imageSize(storage_image);

    if (gl_LaunchIDEXT.x >= image_size.x || gl_LaunchIDEXT.y >= image_size.y)
    {
        return;
    }

    const vec3 position = vec3(-0.07, 0.15, 0.2);
    const vec3 look_at = vec3(-0.02, 0.1, 0.0);
    const vec3 up = vec3(0.0, 1.0, 0.0);
    const float vertical_fov = radians(60.0);
    const float aspect_ratio = image_size.x / image_size.y;
    const vec3 camera_position = position;
    const vec3 camera_local_z = normalize(position - look_at);
    const vec3 camera_local_x = normalize(cross(up, camera_local_z));
    const vec3 camera_local_y = cross(camera_local_z, camera_local_x);
    const float viewport_height = 2.0 * tan(vertical_fov / 2.0);
    const float viewport_width = aspect_ratio * viewport_height;
    const vec3 camera_horizontal = viewport_width * camera_local_x;
    const vec3 camera_vertical = viewport_height * camera_local_y;
    const vec3 camera_lower_left_corner = -camera_horizontal / 2.0 - camera_vertical / 2.0 - camera_local_z;

    payload.rng_state = hash(gl_LaunchIDEXT.y * image_size.x + gl_LaunchIDEXT.x) ^ hash(frame_count);

    vec3 accumulated_pixel_color = vec3(0.0);

    for (uint s = 0; s < samples_per_frame; ++s)
    {
        const float u_offset = random(payload.rng_state);
        const float v_offset = random(payload.rng_state);
        const float u = (float(gl_LaunchIDEXT.x) + u_offset) / float(image_size.x);
        const float v = (float(image_size.y - 1 - gl_LaunchIDEXT.y) + v_offset) / float(image_size.y);

        payload.ray_origin = camera_position;
        payload.ray_direction = normalize(
            camera_lower_left_corner +
            u * camera_horizontal +
            v * camera_vertical);

        vec3 transmitted = vec3(1.0);

        for (uint depth = 0; depth < 32; ++depth)
        {
            traceRayEXT(tlas,
                        gl_RayFlagsOpaqueEXT,
                        0xFF,
                        0,
                        0,
                        0,
                        payload.ray_origin,
                        0.0,
                        payload.ray_direction,
                        10000.0,
                        0);

            transmitted *= payload.color;

            if (payload.hit_sky)
            {
                accumulated_pixel_color += transmitted;
                break;
            }
        }
    }

    vec4 average_color = imageLoad(storage_image, ivec2(gl_LaunchIDEXT.xy));
    average_color = (average_color * frame_count + vec4(accumulated_pixel_color / samples_per_frame, 1.0)) / (frame_count + 1);
    imageStore(storage_image, ivec2(gl_LaunchIDEXT.xy), average_color);
}
